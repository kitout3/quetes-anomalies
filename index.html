<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuÃªtes d'Anomalies - Multijoueur Firebase</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    .animate-spin { animation: spin 1s linear infinite; }
    .dice-roll { animation: spin 0.5s ease-out; }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  <script>
const { useState, useEffect, useMemo, useCallback } = React;
const { createRoot } = ReactDOM;

// ============= FIREBASE CONFIG =============
const firebaseConfig = {
  apiKey: "__FIREBASE_API_KEY__",
  authDomain: "__FIREBASE_AUTH_DOMAIN__",
  databaseURL: "__FIREBASE_DATABASE_URL__",
  projectId: "__FIREBASE_PROJECT_ID__",
  storageBucket: "__FIREBASE_STORAGE_BUCKET__",
  messagingSenderId: "__FIREBASE_MESSAGING_SENDER_ID__",
  appId: "__FIREBASE_APP_ID__"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

// ============= CONSTANTS =============
const CHARACTERS = {
  CHASSEUR: {
    name: "Le Chasseur", pvMax: 6, role: "Harceleur â€“ QuÃªtes â€“ Combat Ã  distance",
    concept: "SpÃ©cialiste du contrÃ´le spatial et de la pression indirecte.",
    skills: ["Peut attaquer Ã  distance d'un biome", "Ne subit aucun dÃ©gÃ¢t de riposte lors d'une attaque Ã  distance", "+1 permanent lors des attaques contre les monstres de quÃªte"],
    style: "Tactique, opportuniste, faible en dÃ©fense directe.", questBonus: 1, noCounterDamage: true
  },
  MARCHAND: {
    name: "Le Marchand", pvMax: 6, role: "Ã‰conomie â€“ Monopoles â€“ Fin de partie",
    concept: "Transforme l'or en levier stratÃ©gique.",
    skills: ["Gagne +4 or en dÃ©but de partie et Ã  chaque passage par le DÃ©part", "Peut acheter des territoires contre de l'or", "+1 PDV supplÃ©mentaire par monopole de ressources"],
    style: "Gestionnaire, sÃ©curisant, extrÃªmement dangereux.", goldBonus: 4, monopoleBonus: 1
  },
  HOMME_BETE: {
    name: "L'Homme-bÃªte", pvMax: 10, role: "Berserker â€“ Combat prolongÃ©",
    concept: "Convertit sa vitalitÃ© en puissance brute.",
    skills: ["Peut augmenter son jet en sacrifiant ses PV", "Se soigne jusqu'Ã  2 PV en cas de victoire", "Inflige 1 dÃ©gÃ¢t de riposte quand attaquÃ©"],
    style: "Agressif, rÃ©silient, trÃ¨s difficile Ã  Ã©liminer.", counterDamage: 1, healOnWin: 2
  },
  CHEVALIER: {
    name: "Le Chevalier", pvMax: 10, role: "ConquÃªte â€“ ContrÃ´le de carte",
    concept: "Chaque victoire militaire devient une expansion.",
    skills: ["Obtient directement le territoire adverse conquis", "+1 lors des attaques de territoires neutres", "+1 PDV par territoire avec monopole de biome"],
    style: "Expansionniste, dominateur, puissant.", territoryBonus: 1, biomeBonus: 1
  },
  VICAIRE: {
    name: "Le Vicaire", pvMax: 8, role: "Support â€“ Optimisation â€“ ContrÃ´le",
    concept: "Manipule la chance et stabilise les situations.",
    skills: ["Relance un dÃ© stat en sacrifiant 1 ressource", "BÃ©nÃ©diction (recharge au DÃ©part)", "+1 PDV supplÃ©mentaire par quÃªte accomplie"],
    style: "Flexible, diplomatique, fort en optimisation.", questPdvBonus: 1, canBless: true
  },
  HERETIQUE: {
    name: "L'HÃ©rÃ©tique", pvMax: 8, role: "Sabotage â€“ MalÃ©dictions â€“ Assassinat",
    concept: "Affaiblit avant d'achever.",
    skills: ["Choisit la statistique en combat joueur", "MalÃ©diction (coÃ»t 3 PV, recharge au DÃ©part)", "+1 PDV si kill d'un joueur maudit"],
    style: "Cruel, calculateur, punitif en duel.", chooseStat: true, canCurse: true, cursedKillBonus: 1
  }
};

const STAT_NAMES = { endurance: "Endurance", force: "Force", vitesse: "Vitesse", perception: "Perception", sagesse: "Sagesse", intelligence: "Intelligence" };
const STAT_MAPPING = { "Endurance": "endurance", "Force": "force", "AgilitÃ©": "vitesse", "Perception": "perception", "Sagesse": "sagesse", "Intelligence": "intelligence" };
const STATISTIQUES = ["Endurance", "Force", "Vitesse", "Perception", "Sagesse", "Intelligence"];

const BIOMES = {
  FORET: { name: "ForÃªt CuivrÃ©e", emoji: "ðŸŒ³", color: "from-green-600 to-green-800", resource: "cuivre" },
  DESERT: { name: "DÃ©sert ArgentÃ©", emoji: "ðŸœï¸", color: "from-yellow-500 to-orange-600", resource: "argent" },
  MONTAGNE: { name: "Montagne Obsidienne", emoji: "â›°ï¸", color: "from-gray-700 to-gray-900", resource: "obsidienne" }
};

const RESOURCE_MAPPING = {
  "PiÃ¨ce d'Or": { key: "or", displayName: "PiÃ¨ces d'Or" },
  "Ecorce CuivrÃ©e": { key: "cuivre", displayName: "Ecorce CuivrÃ©e" },
  "Sable ArgentÃ©": { key: "argent", displayName: "Sable ArgentÃ©" },
  "Roche Obsidienne": { key: "obsidienne", displayName: "Roche Obsidienne" }
};

const PDV_SOURCES = {
  COMBAT: { label: "Combat", emoji: "âš”ï¸", color: "text-red-600" },
  QUEST: { label: "QuÃªte", emoji: "ðŸ“œ", color: "text-green-600" },
  TERRITORY: { label: "Territoire", emoji: "ðŸ°", color: "text-blue-600" },
  MONOPOLE: { label: "Monopole", emoji: "ðŸ‘‘", color: "text-yellow-600" },
  BONUS: { label: "Bonus", emoji: "âœ¨", color: "text-purple-600" }
};

const ANOMALIES = ["Soignez 1 [Point de vie].","Soignez 2 [Point de vie].","Soignez 3 [Point de vie].","Soignez 4 [Point de vie].","Soignez 5 [Point de vie].","Soignez 6 [Point de vie].","Soignez 7 [Point de vie].","Soignez 8 [Point de vie].","Soignez 9 [Point de vie].","Perdez 1 [Point de vie].","Perdez 2 [Point de vie].","Perdez 3 [Point de vie].","Perdez 4 [Point de vie].","Perdez 5 [Point de vie].","Perdez 6 [Point de vie].","Perdez 7 [Point de vie].","Perdez 8 [Point de vie].","Perdez 9 [Point de vie].","Avancez de 1 [Case].","Avancez de 2 [Case].","Avancez de 3 [Case].","Avancez de 4 [Case].","Avancez de 5 [Case].","Avancez de 6 [Case].","Avancez de 7 [Case].","Avancez de 8 [Case].","Avancez de 9 [Case].","Reculez de 1 [Case].","Reculez de 2 [Case].","Reculez de 3 [Case].","Reculez de 4 [Case].","Reculez de 5 [Case].","Reculez de 6 [Case].","Reculez de 7 [Case].","Reculez de 8 [Case].","Reculez de 9 [Case].","Obtenez [BÃ©nÃ©diction] de [Endurance].","Obtenez [BÃ©nÃ©diction] de [Force].","Obtenez [BÃ©nÃ©diction] de [AgilitÃ©].","Obtenez [BÃ©nÃ©diction] de [Perception].","Obtenez [BÃ©nÃ©diction] de [Sagesse].","Obtenez [BÃ©nÃ©diction] de [Intelligence].","Obtenez [MalÃ©diction] de [Endurance].","Obtenez [MalÃ©diction] de [Force].","Obtenez [MalÃ©diction] de [AgilitÃ©].","Obtenez [MalÃ©diction] de [Perception].","Obtenez [MalÃ©diction] de [Sagesse].","Obtenez [MalÃ©diction] de [Intelligence].","Obtenez l'objet [Clefs de la prison].","Allez en [Prison].","Obtenez l'objet [Clefs de la prison].","Allez en [Prison].","Obtenez l'objet [Clefs de la prison].","Allez en [Prison].","Gagnez 8 [PiÃ¨ce d'Or].","Gagnez 4 [PiÃ¨ce d'Or].","Gagnez 6 [Ecorce CuivrÃ©e].","Gagnez 3 [Ecorce CuivrÃ©e].","Gagnez 4 [Sable ArgentÃ©].","Gagnez 2 [Sable ArgentÃ©].","Gagnez 2 [Roche Obsidienne].","Gagnez 1 [Roche Obsidienne].","Perdez 8 [PiÃ¨ce d'Or].","Perdez 4 [PiÃ¨ce d'Or].","Perdez 6 [Ecorce CuivrÃ©e].","Perdez 3 [Ecorce CuivrÃ©e].","Perdez 4 [Sable ArgentÃ©].","Perdez 2 [Sable ArgentÃ©].","Perdez 2 [Roche Obsidienne].","Perdez 1 [Roche Obsidienne]."];

const QUETES = ["Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Endurance] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Force] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [AgilitÃ©] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Perception] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Sagesse] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Intelligence] pour gagner 3 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Endurance] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Force] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [AgilitÃ©] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Perception] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Sagesse] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Intelligence] pour gagner 4 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Endurance] pour gagner 5 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Force] pour gagner 5 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [AgilitÃ©] pour gagner 5 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Perception] pour gagner 5 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Sagesse] pour gagner 5 [Point de victoire].","Dans le territoire [ForÃªt aux arbres CuivrÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Intelligence] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Endurance] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Force] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [AgilitÃ©] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Perception] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Sagesse] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Intelligence] pour gagner 3 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Endurance] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Force] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [AgilitÃ©] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Perception] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Sagesse] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Intelligence] pour gagner 4 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Endurance] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Force] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [AgilitÃ©] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Perception] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Sagesse] pour gagner 5 [Point de victoire].","Dans le territoire [DÃ©sert aux sables ArgentÃ©s], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Intelligence] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Endurance] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Force] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [AgilitÃ©] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Perception] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Sagesse] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 6 en [Intelligence] pour gagner 3 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Endurance] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Force] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [AgilitÃ©] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Perception] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Sagesse] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 8 en [Intelligence] pour gagner 4 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Endurance] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Force] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [AgilitÃ©] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Perception] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Sagesse] pour gagner 5 [Point de victoire].","Dans le territoire [Montagne aux roches Obsdiennes], Ã©liminer la crÃ©ature de difficultÃ© 10 en [Intelligence] pour gagner 5 [Point de victoire].","Echanger 8 [PiÃ¨ce d'Or] contre 2 [Point de victoire].","Echanger 4 [PiÃ¨ce d'Or] contre 1 [Point de victoire].","Echanger 6 [Ecorce CuivrÃ©e] contre 2 [Point de victoire].","Echanger 3 [Ecorce CuivrÃ©e] contre 1 [Point de victoire].","Echanger 4 [Sable ArgentÃ©] contre 2 [Point de victoire].","Echanger 2 [Sable ArgentÃ©] contre 1 [Point de victoire].","Echanger 2 [Roche Obsidienne] contre 2 [Point de victoire].","Echanger 1 [Roche Obsidienne] contre 1 [Point de victoire].","Echanger 8 [PiÃ¨ce d'Or] contre 2 [Point de victoire].","Echanger 4 [PiÃ¨ce d'Or] contre 1 [Point de victoire].","Echanger 6 [Ecorce CuivrÃ©e] contre 2 [Point de victoire].","Echanger 3 [Ecorce CuivrÃ©e] contre 1 [Point de victoire].","Echanger 4 [Sable ArgentÃ©] contre 2 [Point de victoire].","Echanger 2 [Sable ArgentÃ©] contre 1 [Point de victoire].","Echanger 2 [Roche Obsidienne] contre 2 [Point de victoire].","Echanger 1 [Roche Obsidienne] contre 1 [Point de victoire]."];

const MAJOR_EVENTS = [
  "ðŸŒ‹ Ã‰ruption volcanique ! Tous les joueurs perdent 2 PV.",
  "ðŸŒˆ Arc-en-ciel magique ! Tous les joueurs gagnent 1 ressource au choix.",
  "ðŸ‘» Invasion spectrale ! Le prochain combat a +2 de difficultÃ©.",
  "ðŸ’° Pluie d'or ! Tous les joueurs gagnent 3 piÃ¨ces d'or.",
  "ðŸŒªï¸ TempÃªte mystique ! Toutes les bÃ©nÃ©dictions sont annulÃ©es.",
  "ðŸŽ­ Carnaval des masques ! Les joueurs Ã©changent leurs positions.",
  "âš¡ Foudre divine ! Le joueur avec le plus de PDV perd 1 PDV.",
  "ðŸŒ¸ Floraison magique ! Tous les joueurs se soignent de 3 PV."
];

// ============= UTILITY FUNCTIONS =============
function genCode() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

function parseAnomaly(text) {
  const healMatch = text.match(/Soignez (\d+) \[Point de vie\]/);
  if (healMatch) return { type: 'heal', amount: parseInt(healMatch[1]) };
  const damageMatch = text.match(/Perdez (\d+) \[Point de vie\]/);
  if (damageMatch) return { type: 'damage', amount: parseInt(damageMatch[1]) };
  const blessMatch = text.match(/Obtenez \[BÃ©nÃ©diction\] de \[(.+?)\]/);
  if (blessMatch) return { type: 'bless', stat: STAT_MAPPING[blessMatch[1]], statName: blessMatch[1] };
  const curseMatch = text.match(/Obtenez \[MalÃ©diction\] de \[(.+?)\]/);
  if (curseMatch) return { type: 'curse', stat: STAT_MAPPING[curseMatch[1]], statName: curseMatch[1] };
  const gainOrMatch = text.match(/Gagnez (\d+) \[PiÃ¨ce d'Or\]/);
  if (gainOrMatch) return { type: 'gainOr', amount: parseInt(gainOrMatch[1]) };
  const loseOrMatch = text.match(/Perdez (\d+) \[PiÃ¨ce d'Or\]/);
  if (loseOrMatch) return { type: 'loseOr', amount: parseInt(loseOrMatch[1]) };
  const gainCuivreMatch = text.match(/Gagnez (\d+) \[Ecorce CuivrÃ©e\]/);
  if (gainCuivreMatch) return { type: 'gainCuivre', amount: parseInt(gainCuivreMatch[1]) };
  const loseCuivreMatch = text.match(/Perdez (\d+) \[Ecorce CuivrÃ©e\]/);
  if (loseCuivreMatch) return { type: 'loseCuivre', amount: parseInt(loseCuivreMatch[1]) };
  const gainArgentMatch = text.match(/Gagnez (\d+) \[Sable ArgentÃ©\]/);
  if (gainArgentMatch) return { type: 'gainArgent', amount: parseInt(gainArgentMatch[1]) };
  const loseArgentMatch = text.match(/Perdez (\d+) \[Sable ArgentÃ©\]/);
  if (loseArgentMatch) return { type: 'loseArgent', amount: parseInt(loseArgentMatch[1]) };
  const gainObsidienneMatch = text.match(/Gagnez (\d+) \[Roche Obsidienne\]/);
  if (gainObsidienneMatch) return { type: 'gainObsidienne', amount: parseInt(gainObsidienneMatch[1]) };
  const loseObsidienneMatch = text.match(/Perdez (\d+) \[Roche Obsidienne\]/);
  if (loseObsidienneMatch) return { type: 'loseObsidienne', amount: parseInt(loseObsidienneMatch[1]) };
  return { type: 'other', text };
}

function parseQuest(text) {
  const pdvMatch = text.match(/(\d+) \[Point de victoire\]/);
  const pdv = pdvMatch ? parseInt(pdvMatch[1]) : 0;
  const exchangeMatch = text.match(/Echanger (\d+) \[(.+?)\] contre/);
  if (exchangeMatch) {
    const amount = parseInt(exchangeMatch[1]);
    const resourceInfo = RESOURCE_MAPPING[exchangeMatch[2]];
    if (resourceInfo) return { pdv, isExchange: true, isCombat: false, resourceKey: resourceInfo.key, resourceDisplayName: resourceInfo.displayName, resourceAmount: amount };
  }
  const combatMatch = text.match(/Ã©liminer la crÃ©ature de difficultÃ© (\d+) en \[(.+?)\]/);
  if (combatMatch) {
    const difficulty = parseInt(combatMatch[1]);
    const statKey = STAT_MAPPING[combatMatch[2]];
    return { pdv, isExchange: false, isCombat: true, difficulty, stat: statKey, statName: combatMatch[2] };
  }
  return { pdv, isExchange: false, isCombat: false };
}

function countTerritoriesByBiome(territories) {
  const counts = { FORET: 0, DESERT: 0, MONTAGNE: 0 };
  (territories || []).forEach(t => { if (counts[t.biome] !== undefined) counts[t.biome]++; });
  return counts;
}

function getRandomAvailableResource(player) {
  const available = [];
  if (player.or > 0) available.push('or');
  if (player.cuivre > 0) available.push('cuivre');
  if (player.argent > 0) available.push('argent');
  if (player.obsidienne > 0) available.push('obsidienne');
  return available.length > 0 ? available[Math.floor(Math.random() * available.length)] : null;
}

// ============= RULES ENGINE =============
const rulesEngine = {
  canBless: (player) => player.characterKey === 'VICAIRE',
  canCurse: (player) => player.characterKey === 'HERETIQUE',
  canChooseStat: (player) => player.characterKey === 'HERETIQUE',
  canReroll: (player) => player.characterKey === 'VICAIRE',
  getQuestBonus: (player) => player.characterKey === 'CHASSEUR' ? 1 : 0,
  getTerritoryBonus: (player, isNeutral) => (player.characterKey === 'CHEVALIER' && isNeutral) ? 1 : 0,
  getCounterDamage: (player) => player.characterKey === 'HOMME_BETE' ? 1 : 0,
  getHealOnWin: (player) => player.characterKey === 'HOMME_BETE' ? 2 : 0,
  getGoldOnStart: (player) => player.characterKey === 'MARCHAND' ? 4 : 0,
  getMonopoleBonus: (player) => player.characterKey === 'MARCHAND' ? 3 : 2,
  getQuestPdvBonus: (player) => player.characterKey === 'VICAIRE' ? 1 : 0,
  getCursedKillBonus: (player, target) => {
    if (player.characterKey !== 'HERETIQUE') return 0;
    const isCursed = (target.effects || []).some(e => e.type === 'CURSE');
    return isCursed ? 1 : 0;
  },
  computeEffectiveStats: (player) => {
    const effective = {};
    Object.keys(STAT_NAMES).forEach(key => {
      const base = (player.baseStats && player.baseStats[key]) || 0;
      const bonus = (player.effects || []).filter(e => e.stat === key).reduce((sum, e) => sum + e.delta, 0);
      effective[key] = base + bonus;
    });
    return effective;
  }
};

// ============= MAIN APP =============
function App() {
  const [userId, setUserId] = useState(null);
  const [screen, setScreen] = useState('menu');
  const [gameCode, setGameCode] = useState('');
  const [gameState, setGameState] = useState(null);
  const [playerIndex, setPlayerIndex] = useState(-1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    auth.signInAnonymously().then(cred => {
      setUserId(cred.user.uid);
      setLoading(false);
    }).catch(err => {
      setError("Erreur de connexion: " + err.message);
      setLoading(false);
    });
  }, []);

  useEffect(() => {
    if (!gameCode) return;
    const ref = db.ref(`games/${gameCode}`);
    const unsub = ref.on('value', snap => {
      const data = snap.val();
      if (data) {
        // Convert Firebase object to proper array for players
        if (data.players && !Array.isArray(data.players)) {
          data.players = Array(data.playerCount).fill(null).map((_, i) => data.players[i] || null);
        }
        if (data.selectedCharacters && !Array.isArray(data.selectedCharacters)) {
          data.selectedCharacters = Object.values(data.selectedCharacters);
        }
        if (data.drawnAnomalies && !Array.isArray(data.drawnAnomalies)) {
          data.drawnAnomalies = Object.values(data.drawnAnomalies);
        }
        if (data.drawnQuetes && !Array.isArray(data.drawnQuetes)) {
          data.drawnQuetes = Object.values(data.drawnQuetes);
        }
        setGameState(data);
        if (data.players && userId) {
          const idx = data.players.findIndex(p => p && p.odId === userId);
          if (idx >= 0) setPlayerIndex(idx);
        }
      }
    });
    return () => ref.off('value', unsub);
  }, [gameCode, userId]);

  const createGame = async (playerCount) => {
    const code = genCode();
    const newGame = {
      code, playerCount, step: 'lobby', currentTurn: 0,
      players: Array(playerCount).fill(null),
      selectedCharacters: [], drawnAnomalies: [], drawnQuetes: [], events: [],
      createdAt: Date.now(), lastPdvMilestone: 0
    };
    await db.ref(`games/${code}`).set(newGame);
    setGameCode(code);
    setScreen('lobby');
  };

  const joinGame = async (code) => {
    const snap = await db.ref(`games/${code}`).once('value');
    if (!snap.exists()) { setError("Partie introuvable"); return; }
    setGameCode(code);
    setScreen('lobby');
  };

  const joinAsPlayer = async (slot, playerName, characterKey) => {
    if (!gameState || playerIndex >= 0) return;
    const char = CHARACTERS[characterKey];
    const newPlayer = {
      id: `player_${slot}`, odId: userId, playerName, characterKey, character: char,
      pvCurrent: char.pvMax, or: char.goldBonus || 0, cuivre: 0, argent: 0, obsidienne: 0,
      pdv: 0, tourPlateau: 0, baseStats: null, effects: [], quests: [], territories: [],
      skills: char.skills.map((s, i) => ({ id: `skill_${i}`, description: s, status: 'AVAILABLE' })),
      usedAttackDice: false, blessAvailable: true, curseAvailable: true, rerollAvailable: true,
      pdvHistory: [], ready: false
    };
    const updates = {};
    updates[`players/${slot}`] = newPlayer;
    updates[`selectedCharacters`] = [...(gameState.selectedCharacters || []), characterKey];
    await db.ref(`games/${gameCode}`).update(updates);
    setPlayerIndex(slot);
  };

  const allocateStats = async (stats) => {
    if (playerIndex < 0) return;
    await db.ref(`games/${gameCode}/players/${playerIndex}`).update({ baseStats: stats, ready: true });
  };

  const startGame = async () => {
    const players = Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null);
    const allReady = players.every(p => p && p.ready && p.baseStats);
    if (!allReady) { alert("Tous les joueurs doivent Ãªtre prÃªts !"); return; }
    await db.ref(`games/${gameCode}`).update({ step: 'play' });
  };

  const updatePlayer = async (idx, updates) => {
    await db.ref(`games/${gameCode}/players/${idx}`).update(updates);
  };

  const updateGame = async (updates) => {
    await db.ref(`games/${gameCode}`).update(updates);
  };

  const nextTurn = async () => {
    const players = Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null);
    const newPlayers = [...players];
    if (newPlayers[gameState.currentTurn]) {
      newPlayers[gameState.currentTurn] = { ...newPlayers[gameState.currentTurn], usedAttackDice: false };
    }
    const nextIdx = (gameState.currentTurn + 1) % gameState.playerCount;
    await db.ref(`games/${gameCode}`).update({ players: newPlayers, currentTurn: nextIdx });
  };

  if (loading) return React.createElement("div", { className: "min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-900 to-blue-900" },
    React.createElement("div", { className: "text-white text-2xl animate-pulse" }, "Connexion...")
  );

  if (error) return React.createElement("div", { className: "min-h-screen flex items-center justify-center bg-red-900 p-6" },
    React.createElement("div", { className: "bg-white rounded-xl p-6 text-center" },
      React.createElement("p", { className: "text-red-600 font-bold mb-4" }, error),
      React.createElement("button", { onClick: () => { setError(null); setScreen('menu'); }, className: "px-6 py-2 bg-blue-600 text-white rounded-lg" }, "Retour")
    )
  );

  if (screen === 'menu') return React.createElement(MenuScreen, { onCreateGame: () => setScreen('create'), onJoinGame: () => setScreen('join') });
  if (screen === 'create') return React.createElement(CreateGameScreen, { onCreate: createGame, onBack: () => setScreen('menu') });
  if (screen === 'join') return React.createElement(JoinGameScreen, { onJoin: joinGame, onBack: () => setScreen('menu') });

  if (screen === 'lobby' && gameState) {
    if (gameState.step === 'lobby') {
      return React.createElement(LobbyScreen, {
        gameState, gameCode, userId, playerIndex,
        onJoinAsPlayer: joinAsPlayer, onAllocateStats: allocateStats, onStartGame: startGame
      });
    }
    if (gameState.step === 'play') {
      const currentPlayer = gameState.players[playerIndex];
      const isMyTurn = gameState.currentTurn === playerIndex;
      return React.createElement(TurnGameScreen, {
        gameState, gameCode, currentPlayer, playerIndex, isMyTurn,
        updatePlayer, updateGame, nextTurn
      });
    }
  }

  return React.createElement("div", { className: "min-h-screen flex items-center justify-center" },
    React.createElement("p", null, "Chargement...")
  );
}

// ============= MENU SCREEN =============
function MenuScreen({ onCreateGame, onJoinGame }) {
  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-900 to-blue-900 flex items-center justify-center p-6" },
    React.createElement("div", { className: "bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center" },
      React.createElement("h1", { className: "text-4xl font-bold text-gray-800 mb-2" }, "QuÃªtes d'Anomalies"),
      React.createElement("p", { className: "text-gray-600 mb-2" }, "v2.3 - Multijoueur Firebase"),
      React.createElement("p", { className: "text-sm text-purple-600 mb-8" }, "ðŸŒ Jouez en ligne avec vos amis !"),
      React.createElement("button", { onClick: onCreateGame, className: "w-full py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-xl font-bold text-lg mb-4 hover:from-purple-700 hover:to-blue-700" }, "ðŸ†• CrÃ©er une partie"),
      React.createElement("button", { onClick: onJoinGame, className: "w-full py-4 bg-gradient-to-r from-green-600 to-teal-600 text-white rounded-xl font-bold text-lg hover:from-green-700 hover:to-teal-700" }, "ðŸ”— Rejoindre une partie")
    )
  );
}

// ============= CREATE GAME SCREEN =============
function CreateGameScreen({ onCreate, onBack }) {
  const [count, setCount] = useState(2);
  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-900 to-blue-900 flex items-center justify-center p-6" },
    React.createElement("div", { className: "bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full" },
      React.createElement("h2", { className: "text-3xl font-bold text-center text-gray-800 mb-6" }, "Nouvelle Partie"),
      React.createElement("label", { className: "block text-lg font-semibold text-gray-700 mb-4 text-center" }, "Nombre de joueurs"),
      React.createElement("div", { className: "flex items-center justify-center gap-4 mb-6" },
        React.createElement("button", { onClick: () => setCount(Math.max(1, count - 1)), className: "w-12 h-12 bg-purple-600 text-white rounded-full font-bold text-xl" }, "-"),
        React.createElement("div", { className: "text-5xl font-bold text-purple-600 w-16 text-center" }, count),
        React.createElement("button", { onClick: () => setCount(Math.min(11, count + 1)), className: "w-12 h-12 bg-purple-600 text-white rounded-full font-bold text-xl" }, "+")
      ),
      React.createElement("div", { className: "flex gap-2 flex-wrap justify-center mb-6" },
        [1,2,3,4,5,6,7,8,9,10,11].map(n => React.createElement("button", {
          key: n, onClick: () => setCount(n),
          className: `w-10 h-10 rounded-lg font-semibold ${count === n ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}`
        }, n))
      ),
      React.createElement("button", { onClick: () => onCreate(count), className: "w-full py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-xl font-bold text-lg mb-3" }, "CrÃ©er la partie"),
      React.createElement("button", { onClick: onBack, className: "w-full py-3 bg-gray-200 text-gray-700 rounded-xl font-semibold" }, "Retour")
    )
  );
}

// ============= JOIN GAME SCREEN =============
function JoinGameScreen({ onJoin, onBack }) {
  const [code, setCode] = useState('');
  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-900 to-blue-900 flex items-center justify-center p-6" },
    React.createElement("div", { className: "bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full" },
      React.createElement("h2", { className: "text-3xl font-bold text-center text-gray-800 mb-6" }, "Rejoindre une partie"),
      React.createElement("label", { className: "block text-sm font-semibold text-gray-700 mb-2" }, "Code de la partie"),
      React.createElement("input", {
        type: "text", value: code, onChange: e => setCode(e.target.value.toUpperCase()),
        placeholder: "Ex: ABC123", maxLength: 6,
        className: "w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-center text-2xl font-bold tracking-widest mb-6"
      }),
      React.createElement("button", {
        onClick: () => code.length === 6 && onJoin(code), disabled: code.length !== 6,
        className: `w-full py-4 rounded-xl font-bold text-lg mb-3 ${code.length === 6 ? 'bg-gradient-to-r from-green-600 to-teal-600 text-white' : 'bg-gray-300 text-gray-500'}`
      }, "Rejoindre"),
      React.createElement("button", { onClick: onBack, className: "w-full py-3 bg-gray-200 text-gray-700 rounded-xl font-semibold" }, "Retour")
    )
  );
}

// ============= LOBBY SCREEN =============
function LobbyScreen({ gameState, gameCode, userId, playerIndex, onJoinAsPlayer, onAllocateStats, onStartGame }) {
  const [selectedSlot, setSelectedSlot] = useState(null);
  const [playerName, setPlayerName] = useState('');
  const [selectedChar, setSelectedChar] = useState(null);
  const [showStatAlloc, setShowStatAlloc] = useState(false);

  // Ensure players is always an array
  const players = Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null);
  const selectedCharacters = Array.isArray(gameState.selectedCharacters) ? gameState.selectedCharacters : Object.values(gameState.selectedCharacters || {});

  const currentPlayer = playerIndex >= 0 ? players[playerIndex] : null;
  const needsStats = currentPlayer && !currentPlayer.baseStats;

  if (needsStats && !showStatAlloc) setShowStatAlloc(true);

  if (showStatAlloc && currentPlayer) {
    return React.createElement(StatAllocationScreen, {
      player: currentPlayer,
      onComplete: (stats) => { onAllocateStats(stats); setShowStatAlloc(false); }
    });
  }

  const handleJoin = () => {
    if (selectedSlot !== null && playerName.trim() && selectedChar) {
      onJoinAsPlayer(selectedSlot, playerName.trim(), selectedChar);
      setSelectedSlot(null); setPlayerName(''); setSelectedChar(null);
    }
  };

  const allReady = players.every(p => p && p.ready && p.baseStats);
  const isHost = players[0]?.odId === userId;

  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 p-6" },
    React.createElement("div", { className: "max-w-4xl mx-auto" },
      React.createElement("div", { className: "bg-white rounded-2xl shadow-lg p-6 mb-6 text-center" },
        React.createElement("h2", { className: "text-3xl font-bold text-gray-800 mb-2" }, "Salon d'attente"),
        React.createElement("div", { className: "bg-purple-100 rounded-lg p-4 mb-4" },
          React.createElement("p", { className: "text-sm text-gray-600 mb-1" }, "Code de la partie :"),
          React.createElement("p", { className: "text-4xl font-bold text-purple-600 tracking-widest" }, gameCode)
        ),
        React.createElement("p", { className: "text-gray-600" }, `${players.filter(p => p).length} / ${gameState.playerCount} joueurs`)
      ),

      React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-6" },
        players.map((player, idx) => React.createElement("div", {
          key: idx,
          onClick: () => !player && playerIndex < 0 && setSelectedSlot(idx),
          className: `rounded-xl p-4 border-2 transition-all ${player ? (player.ready ? 'bg-green-50 border-green-400' : 'bg-yellow-50 border-yellow-400') : (selectedSlot === idx ? 'bg-purple-100 border-purple-500' : 'bg-gray-50 border-gray-300 hover:border-purple-400 cursor-pointer')}`
        },
          player ? React.createElement("div", null,
            React.createElement("div", { className: "flex items-center justify-between mb-2" },
              React.createElement("span", { className: "font-bold text-gray-800" }, player.playerName),
              React.createElement("span", { className: `px-2 py-1 rounded text-xs font-bold ${player.ready ? 'bg-green-500 text-white' : 'bg-yellow-500 text-white'}` }, player.ready ? "âœ“ PrÃªt" : "En attente")
            ),
            React.createElement("p", { className: "text-sm text-purple-600" }, player.character?.name || 'Personnage')
          ) : React.createElement("div", { className: "text-center py-4" },
            React.createElement("p", { className: "text-gray-400" }, `Place ${idx + 1}`),
            React.createElement("p", { className: "text-sm text-gray-500" }, "Cliquez pour rejoindre")
          )
        ))
      ),

      selectedSlot !== null && playerIndex < 0 && React.createElement("div", { className: "bg-white rounded-2xl shadow-lg p-6 mb-6" },
        React.createElement("h3", { className: "text-xl font-bold text-gray-800 mb-4" }, `Rejoindre - Place ${selectedSlot + 1}`),
        React.createElement("input", {
          type: "text", value: playerName, onChange: e => setPlayerName(e.target.value),
          placeholder: "Votre nom...", className: "w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4"
        }),
        React.createElement("p", { className: "font-semibold text-gray-700 mb-3" }, "Choisissez votre personnage :"),
        React.createElement("div", { className: "grid grid-cols-2 md:grid-cols-3 gap-3 mb-4" },
          Object.entries(CHARACTERS).map(([key, char]) => {
            const taken = selectedCharacters.includes(key);
            return React.createElement("button", {
              key, onClick: () => !taken && setSelectedChar(key), disabled: taken,
              className: `p-3 rounded-lg border-2 text-left transition-all ${taken ? 'bg-gray-100 border-gray-200 opacity-50' : selectedChar === key ? 'bg-purple-100 border-purple-500' : 'bg-white border-gray-300 hover:border-purple-400'}`
            },
              React.createElement("p", { className: "font-bold text-sm" }, char.name),
              React.createElement("p", { className: "text-xs text-gray-500" }, `â¤ï¸ ${char.pvMax} PV`),
              taken && React.createElement("span", { className: "text-xs text-red-500" }, "Pris")
            );
          })
        ),
        React.createElement("button", {
          onClick: handleJoin, disabled: !playerName.trim() || !selectedChar,
          className: `w-full py-3 rounded-xl font-bold ${playerName.trim() && selectedChar ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-500'}`
        }, "Rejoindre la partie")
      ),

      currentPlayer && React.createElement("div", { className: "bg-green-50 rounded-xl p-4 mb-6 text-center" },
        React.createElement("p", { className: "text-green-700 font-semibold" }, `âœ“ Vous jouez ${currentPlayer.playerName} (${currentPlayer.character?.name || 'Personnage'})`),
        currentPlayer.ready && React.createElement("p", { className: "text-green-600 text-sm mt-1" }, "En attente des autres joueurs...")
      ),

      isHost && allReady && React.createElement("button", {
        onClick: onStartGame,
        className: "w-full py-4 bg-gradient-to-r from-green-600 to-teal-600 text-white rounded-xl font-bold text-lg"
      }, "ðŸŽ® Lancer la partie !")
    )
  );
}

// ============= STAT ALLOCATION SCREEN =============
function StatAllocationScreen({ player, onComplete }) {
  const MODIFIERS = [-2, -1, 0, 0, 1, 2];
  const [allocation, setAllocation] = useState({ endurance: null, force: null, vitesse: null, perception: null, sagesse: null, intelligence: null });

  const isModifierUsed = (mod) => {
    const used = Object.values(allocation).filter(v => v === mod).length;
    const total = MODIFIERS.filter(m => m === mod).length;
    return used >= total;
  };

  const handleClick = (stat, mod) => {
    if (allocation[stat] === mod) setAllocation({ ...allocation, [stat]: null });
    else if (!isModifierUsed(mod) || allocation[stat] !== null) setAllocation({ ...allocation, [stat]: mod });
  };

  const isValid = Object.values(allocation).every(v => v !== null);

  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 p-6" },
    React.createElement("div", { className: "max-w-2xl mx-auto" },
      React.createElement("div", { className: "bg-white rounded-2xl shadow-lg p-6 mb-6 text-center" },
        React.createElement("h2", { className: "text-2xl font-bold text-gray-800" }, player.playerName),
        React.createElement("p", { className: "text-purple-600" }, player.character.name)
      ),
      React.createElement("div", { className: "bg-white rounded-2xl shadow-lg p-6 mb-6" },
        React.createElement("h3", { className: "text-xl font-bold text-gray-800 mb-4" }, "RÃ©partition des modificateurs"),
        React.createElement("p", { className: "text-gray-600 mb-6" }, "Assignez -2, -1, 0, 0, +1, +2 aux statistiques"),
        React.createElement("div", { className: "space-y-4" },
          Object.entries(STAT_NAMES).map(([key, name]) => React.createElement("div", { key, className: "bg-gray-50 rounded-lg p-4" },
            React.createElement("div", { className: "font-semibold text-gray-700 mb-3" }, name),
            React.createElement("div", { className: "flex gap-2 justify-center flex-wrap" },
              MODIFIERS.map((mod, idx) => {
                const isSel = allocation[key] === mod;
                const isDis = !isSel && isModifierUsed(mod);
                return React.createElement("button", {
                  key: idx, onClick: () => handleClick(key, mod), disabled: isDis,
                  className: `w-12 h-12 rounded-full font-bold transition-all ${isSel ? (mod >= 0 ? 'bg-green-600 text-white ring-4 ring-green-300' : 'bg-red-600 text-white ring-4 ring-red-300') : isDis ? 'bg-gray-200 text-gray-400' : 'bg-white border-2 border-gray-300 hover:border-purple-500'}`
                }, mod > 0 ? `+${mod}` : mod);
              })
            )
          ))
        ),
        React.createElement("div", { className: "mt-6 p-4 bg-blue-50 rounded-lg text-center" },
          isValid ? React.createElement("span", { className: "text-green-600 font-bold" }, "âœ“ PrÃªt !") : React.createElement("span", { className: "text-gray-600" }, "Assignez tous les modificateurs")
        )
      ),
      React.createElement("button", {
        onClick: () => isValid && onComplete(allocation), disabled: !isValid,
        className: `w-full py-4 rounded-xl font-bold text-lg ${isValid ? 'bg-gradient-to-r from-purple-600 to-blue-600 text-white' : 'bg-gray-300 text-gray-500'}`
      }, "Valider")
    )
  );
}

// ============= TURN GAME SCREEN =============
function TurnGameScreen({ gameState, gameCode, currentPlayer, playerIndex, isMyTurn, updatePlayer, updateGame, nextTurn }) {
  const [activeTab, setActiveTab] = useState('anomalie');
  const [showDeath, setShowDeath] = useState(false);
  const [showPassStart, setShowPassStart] = useState(false);
  const [showEndGame, setShowEndGame] = useState(false);

  // Ensure players is always an array
  const players = Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null);
  const activePlayer = players[gameState.currentTurn];
  const totalPdv = players.reduce((s, p) => s + (p?.pdv || 0), 0);
  const targetPdv = gameState.playerCount * 10;

  useEffect(() => {
    if (currentPlayer && currentPlayer.pvCurrent <= 0 && !showDeath) setShowDeath(true);
  }, [currentPlayer?.pvCurrent]);

  useEffect(() => {
    if (totalPdv >= targetPdv && !showEndGame) setShowEndGame(true);
  }, [totalPdv, targetPdv]);

  const handleDeath = async () => {
    await updatePlayer(playerIndex, { pvCurrent: currentPlayer.character.pvMax, effects: [], tourPlateau: 0 });
    setShowDeath(false);
  };

  const handlePassStart = async () => {
    const goldBonus = rulesEngine.getGoldOnStart(currentPlayer);
    const territoryCount = countTerritoriesByBiome(currentPlayer.territories);
    const resourceGains = { or: goldBonus, cuivre: territoryCount.FORET, argent: territoryCount.DESERT, obsidienne: territoryCount.MONTAGNE };
    await updatePlayer(playerIndex, {
      or: currentPlayer.or + resourceGains.or,
      cuivre: currentPlayer.cuivre + resourceGains.cuivre,
      argent: currentPlayer.argent + resourceGains.argent,
      obsidienne: currentPlayer.obsidienne + resourceGains.obsidienne,
      tourPlateau: currentPlayer.tourPlateau + 1,
      blessAvailable: true, curseAvailable: true, rerollAvailable: true
    });
    setShowPassStart(false);
  };

  if (showDeath) return React.createElement(DeathOverlay, { player: currentPlayer, onContinue: handleDeath });
  if (showPassStart) return React.createElement(StartPassOverlay, { player: currentPlayer, onConfirm: handlePassStart, onCancel: () => setShowPassStart(false) });
  if (showEndGame) return React.createElement(EndGameScreen, { gameState, onRestart: () => window.location.reload() });

  const tabs = ['anomalie', 'quete', 'statistique', 'de', 'personnage'];

  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 flex flex-col" },
    React.createElement("div", { className: `p-4 text-white ${isMyTurn ? 'bg-gradient-to-r from-green-600 to-teal-600' : 'bg-gradient-to-r from-gray-600 to-gray-700'}` },
      React.createElement("div", { className: "max-w-4xl mx-auto flex items-center justify-between" },
        React.createElement("div", null,
          React.createElement("div", { className: "text-sm font-semibold" }, isMyTurn ? "ðŸŽ¯ VOTRE TOUR" : `Tour de ${activePlayer?.playerName || '...'}`),
          React.createElement("h2", { className: "text-xl font-bold" }, currentPlayer?.playerName),
          React.createElement("p", { className: "text-sm opacity-90" }, currentPlayer?.character?.name)
        ),
        React.createElement("div", { className: "text-right" },
          React.createElement("div", { className: "text-3xl font-bold" }, `${currentPlayer?.pvCurrent || 0}/${currentPlayer?.character?.pvMax || 0}`),
          React.createElement("div", { className: "text-xs" }, "Points de Vie"),
          React.createElement("div", { className: "text-sm mt-1" }, `ðŸ† ${currentPlayer?.pdv || 0} PDV`)
        )
      )
    ),

    React.createElement("div", { className: "bg-white shadow-md overflow-x-auto" },
      React.createElement("div", { className: "max-w-4xl mx-auto flex" },
        tabs.map(tab => React.createElement("button", {
          key: tab, onClick: () => setActiveTab(tab),
          className: `flex-shrink-0 px-4 py-3 font-semibold text-sm border-b-4 ${activeTab === tab ? 'bg-blue-600 text-white border-blue-800' : 'bg-gray-100 text-gray-600 border-transparent'}`
        }, tab === 'anomalie' ? 'ðŸŽ´ Anomalie' : tab === 'quete' ? 'ðŸ“œ QuÃªte' : tab === 'statistique' ? 'ðŸ“Š Stat' : tab === 'de' ? 'ðŸŽ² DÃ©' : 'ðŸ‘¤ Perso'))
      )
    ),

    React.createElement("div", { className: "flex-1 overflow-y-auto" },
      React.createElement("div", { className: "max-w-4xl mx-auto p-4" },
        React.createElement("div", { className: "bg-white rounded-2xl shadow-lg p-6 mb-4" },
          activeTab === 'anomalie' && React.createElement(AnomalieTab, { player: currentPlayer, gameState, updateGame, updatePlayer: (u) => updatePlayer(playerIndex, u), isMyTurn }),
          activeTab === 'quete' && React.createElement(QueteTab, { player: currentPlayer, gameState, updateGame, updatePlayer: (u) => updatePlayer(playerIndex, u), isMyTurn }),
          activeTab === 'statistique' && React.createElement(StatistiqueTab, {}),
          activeTab === 'de' && React.createElement(DeTab, { player: currentPlayer, gameState, players, updatePlayer: (idx, u) => updatePlayer(idx, u), playerIndex, isMyTurn }),
          activeTab === 'personnage' && React.createElement(PersonnageTab, { player: currentPlayer, updatePlayer: (u) => updatePlayer(playerIndex, u), gameState, players, updateGame, playerIndex, onPassStart: () => setShowPassStart(true), isMyTurn })
        ),

        React.createElement("div", { className: "bg-purple-100 rounded-xl p-3 mb-4" },
          React.createElement("div", { className: "flex justify-between items-center text-sm" },
            React.createElement("span", { className: "text-purple-700 font-semibold" }, `Total PDV: ${totalPdv} / ${targetPdv}`),
            React.createElement("span", { className: "text-purple-600" }, `${Math.round(totalPdv / targetPdv * 100)}%`)
          ),
          React.createElement("div", { className: "w-full bg-purple-200 rounded-full h-2 mt-2" },
            React.createElement("div", { className: "bg-purple-600 h-2 rounded-full transition-all", style: { width: `${Math.min(100, totalPdv / targetPdv * 100)}%` } })
          )
        ),

        React.createElement("button", {
          onClick: nextTurn, disabled: !isMyTurn,
          className: `w-full py-4 rounded-xl font-bold text-lg ${isMyTurn ? 'bg-gradient-to-r from-green-600 to-teal-600 text-white' : 'bg-gray-300 text-gray-500'}`
        }, isMyTurn ? "âœ“ Fin du tour" : "En attente...")
      )
    )
  );
}

// ============= OVERLAYS =============
function DeathOverlay({ player, onContinue }) {
  return React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-6" },
    React.createElement("div", { className: "bg-white rounded-2xl p-8 max-w-md w-full text-center" },
      React.createElement("div", { className: "text-6xl mb-4" }, "ðŸ’€"),
      React.createElement("h2", { className: "text-3xl font-bold text-red-600 mb-4" }, "Mort !"),
      React.createElement("p", { className: "text-gray-600 mb-6" }, `${player.playerName} a Ã©tÃ© vaincu et retourne au dÃ©part.`),
      React.createElement("button", { onClick: onContinue, className: "w-full py-3 bg-red-600 text-white rounded-xl font-bold" }, "Continuer")
    )
  );
}

function StartPassOverlay({ player, onConfirm, onCancel }) {
  const goldBonus = rulesEngine.getGoldOnStart(player);
  const territories = countTerritoriesByBiome(player.territories);
  return React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-6" },
    React.createElement("div", { className: "bg-white rounded-2xl p-6 max-w-md w-full" },
      React.createElement("h2", { className: "text-2xl font-bold text-amber-600 mb-4 text-center" }, "ðŸ Passage par le DÃ©part"),
      React.createElement("div", { className: "bg-amber-50 rounded-xl p-4 mb-4" },
        React.createElement("p", { className: "font-semibold text-gray-700 mb-2" }, "Vous recevez :"),
        goldBonus > 0 && React.createElement("p", { className: "text-amber-700" }, `ðŸª™ +${goldBonus} Or (Marchand)`),
        territories.FORET > 0 && React.createElement("p", { className: "text-green-700" }, `ðŸŒ³ +${territories.FORET} Cuivre`),
        territories.DESERT > 0 && React.createElement("p", { className: "text-yellow-700" }, `ðŸœï¸ +${territories.DESERT} Argent`),
        territories.MONTAGNE > 0 && React.createElement("p", { className: "text-gray-700" }, `â›°ï¸ +${territories.MONTAGNE} Obsidienne`),
        React.createElement("p", { className: "text-purple-700 mt-2" }, "âœ¨ Pouvoirs rechargÃ©s !")
      ),
      React.createElement("div", { className: "flex gap-3" },
        React.createElement("button", { onClick: onCancel, className: "flex-1 py-3 bg-gray-200 text-gray-700 rounded-xl font-semibold" }, "Annuler"),
        React.createElement("button", { onClick: onConfirm, className: "flex-1 py-3 bg-amber-500 text-white rounded-xl font-bold" }, "Confirmer")
      )
    )
  );
}

function EndGameScreen({ gameState, onRestart }) {
  const players = Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null);
  const ranking = [...players].filter(p => p).sort((a, b) => (b?.pdv || 0) - (a?.pdv || 0));
  const winner = ranking[0];
  return React.createElement("div", { className: "min-h-screen bg-gradient-to-br from-yellow-400 to-orange-500 flex items-center justify-center p-6" },
    React.createElement("div", { className: "bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center" },
      React.createElement("div", { className: "text-6xl mb-4" }, "ðŸ†"),
      React.createElement("h1", { className: "text-4xl font-bold text-gray-800 mb-2" }, "Victoire !"),
      React.createElement("p", { className: "text-2xl text-amber-600 font-bold mb-6" }, winner?.playerName),
      React.createElement("div", { className: "space-y-3 mb-6" },
        ranking.map((p, i) => p && React.createElement("div", {
          key: p.id,
          className: `flex items-center justify-between p-3 rounded-lg ${i === 0 ? 'bg-yellow-100' : 'bg-gray-50'}`
        },
          React.createElement("span", { className: `font-bold ${i === 0 ? 'text-yellow-600' : i === 1 ? 'text-gray-400' : i === 2 ? 'text-amber-600' : 'text-gray-600'}` }, `#${i + 1}`),
          React.createElement("span", { className: "font-semibold" }, p.playerName),
          React.createElement("span", { className: "font-bold text-purple-600" }, `${p.pdv} PDV`)
        ))
      ),
      React.createElement("button", { onClick: onRestart, className: "w-full py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-xl font-bold" }, "Nouvelle partie")
    )
  );
}

// ============= ANOMALIE TAB =============
function AnomalieTab({ player, gameState, updateGame, updatePlayer, isMyTurn }) {
  const [currentCard, setCurrentCard] = useState(null);
  const [isAnimating, setIsAnimating] = useState(false);

  const drawCard = async () => {
    if (!isMyTurn) return;
    const available = ANOMALIES.filter((_, i) => !(gameState.drawnAnomalies || []).includes(i));
    if (available.length === 0) { alert("Toutes les anomalies ont Ã©tÃ© tirÃ©es !"); return; }

    setIsAnimating(true);
    setTimeout(async () => {
      const idx = Math.floor(Math.random() * available.length);
      const card = available[idx];
      const origIdx = ANOMALIES.indexOf(card);

      await updateGame({ drawnAnomalies: [...(gameState.drawnAnomalies || []), origIdx] });
      setCurrentCard(card);
      setIsAnimating(false);

      const effect = parseAnomaly(card);
      applyEffect(effect);
    }, 300);
  };

  const applyEffect = async (effect) => {
    const updates = {};
    if (effect.type === 'heal') updates.pvCurrent = Math.min(player.character.pvMax, player.pvCurrent + effect.amount);
    else if (effect.type === 'damage') updates.pvCurrent = Math.max(0, player.pvCurrent - effect.amount);
    else if (effect.type === 'bless') updates.effects = [...(player.effects || []), { id: `eff_${Date.now()}`, type: 'BLESS', stat: effect.stat, delta: 2, name: `BÃ©nÃ©diction de ${effect.statName}` }];
    else if (effect.type === 'curse') updates.effects = [...(player.effects || []), { id: `eff_${Date.now()}`, type: 'CURSE', stat: effect.stat, delta: -2, name: `MalÃ©diction de ${effect.statName}` }];
    else if (effect.type === 'gainOr') updates.or = player.or + effect.amount;
    else if (effect.type === 'loseOr') updates.or = Math.max(0, player.or - effect.amount);
    else if (effect.type === 'gainCuivre') updates.cuivre = player.cuivre + effect.amount;
    else if (effect.type === 'loseCuivre') updates.cuivre = Math.max(0, player.cuivre - effect.amount);
    else if (effect.type === 'gainArgent') updates.argent = player.argent + effect.amount;
    else if (effect.type === 'loseArgent') updates.argent = Math.max(0, player.argent - effect.amount);
    else if (effect.type === 'gainObsidienne') updates.obsidienne = player.obsidienne + effect.amount;
    else if (effect.type === 'loseObsidienne') updates.obsidienne = Math.max(0, player.obsidienne - effect.amount);
    if (Object.keys(updates).length > 0) await updatePlayer(updates);
  };

  const resetDeck = async () => {
    if (confirm("RÃ©initialiser le deck d'anomalies ?")) {
      await updateGame({ drawnAnomalies: [] });
      setCurrentCard(null);
    }
  };

  const remaining = ANOMALIES.length - (gameState.drawnAnomalies || []).length;

  return React.createElement("div", { className: "space-y-6" },
    React.createElement("div", { className: "text-center" },
      React.createElement("h3", { className: "text-2xl font-bold text-gray-800 mb-2" }, "ðŸŽ´ Anomalies"),
      React.createElement("p", { className: "text-gray-600" }, `Cartes restantes: ${remaining} / ${ANOMALIES.length}`)
    ),
    React.createElement("div", { className: `min-h-[180px] bg-gradient-to-r from-purple-600 to-purple-800 rounded-xl p-6 flex items-center justify-center transition-all ${isAnimating ? 'scale-95 opacity-50' : ''}` },
      currentCard ? React.createElement("p", { className: "text-lg text-center text-white font-medium" }, currentCard) : React.createElement("p", { className: "text-gray-300 text-center italic" }, 'Cliquez sur "Tirer une anomalie"')
    ),
    React.createElement("div", { className: "grid grid-cols-2 gap-4" },
      React.createElement("button", { onClick: drawCard, disabled: !isMyTurn || isAnimating, className: `py-4 rounded-xl font-semibold ${isMyTurn ? 'bg-purple-600 text-white hover:bg-purple-700' : 'bg-gray-300 text-gray-500'}` }, "Tirer une anomalie"),
      React.createElement("button", { onClick: resetDeck, className: "py-4 bg-gray-600 text-white rounded-xl font-semibold hover:bg-gray-700" }, "RÃ©initialiser")
    ),
    React.createElement("div", { className: "bg-blue-50 rounded-xl p-4 text-sm text-gray-700" },
      React.createElement("p", { className: "font-semibold" }, "â„¹ï¸ Application automatique :"),
      React.createElement("p", { className: "text-xs mt-1" }, "Soins, dÃ©gÃ¢ts, bÃ©nÃ©dictions, malÃ©dictions et ressources sont appliquÃ©s automatiquement.")
    )
  );
}

// ============= QUETE TAB =============
function QueteTab({ player, gameState, updateGame, updatePlayer, isMyTurn }) {
  const [currentCard, setCurrentCard] = useState(null);
  const [isAnimating, setIsAnimating] = useState(false);
  const [attemptResult, setAttemptResult] = useState(null);
  const [pendingQuest, setPendingQuest] = useState(null);

  const drawCard = async () => {
    if (!isMyTurn) return;
    const available = QUETES.filter((_, i) => !(gameState.drawnQuetes || []).includes(i));
    if (available.length === 0) { alert("Toutes les quÃªtes ont Ã©tÃ© tirÃ©es !"); return; }

    setIsAnimating(true);
    setTimeout(async () => {
      const idx = Math.floor(Math.random() * available.length);
      const card = available[idx];
      const origIdx = QUETES.indexOf(card);

      await updateGame({ drawnQuetes: [...(gameState.drawnQuetes || []), origIdx] });
      setCurrentCard(card);
      setIsAnimating(false);

      const newQuest = { id: `quest_${Date.now()}`, text: card, completed: false };
      if ((player.quests || []).length >= 2) {
        setPendingQuest(newQuest);
      } else {
        await updatePlayer({ quests: [...(player.quests || []), newQuest] });
      }
    }, 300);
  };

  const handleQuestChoice = async (action, questIdToRemove = null) => {
    if (action === 'refuse') {
      setPendingQuest(null);
    } else if (action === 'replace' && questIdToRemove) {
      const newQuests = (player.quests || []).filter(q => q.id !== questIdToRemove);
      newQuests.push(pendingQuest);
      await updatePlayer({ quests: newQuests });
      setPendingQuest(null);
    }
  };

  const attemptQuest = async (questId, questText) => {
    if (!isMyTurn || player.usedAttackDice) { alert("Jet d'attaque dÃ©jÃ  utilisÃ© ce tour !"); return; }
    const questInfo = parseQuest(questText);
    if (!questInfo.isCombat) return;

    const statKey = questInfo.stat;
    const diceRoll = Math.floor(Math.random() * 10);
    const baseStat = (player.baseStats && player.baseStats[statKey]) || 0;
    const effectsBonus = (player.effects || []).filter(e => e.stat === statKey).reduce((s, e) => s + e.delta, 0);
    const questBonus = rulesEngine.getQuestBonus(player);
    const total = diceRoll + baseStat + effectsBonus + questBonus;
    const success = total >= questInfo.difficulty;

    setAttemptResult({ stat: STAT_NAMES[statKey], diceRoll, baseStat, effectsBonus, questBonus, total, difficulty: questInfo.difficulty, success, pdv: questInfo.pdv });

    const updates = { usedAttackDice: true };
    if (success) {
      updates.quests = (player.quests || []).filter(q => q.id !== questId);
      const pdvBonus = rulesEngine.getQuestPdvBonus(player);
      updates.pdv = player.pdv + questInfo.pdv + pdvBonus;
      updates.pdvHistory = [...(player.pdvHistory || []), { id: `pdv_${Date.now()}`, amount: questInfo.pdv + pdvBonus, source: 'QUEST' }];
    } else {
      const damage = Math.max(1, questInfo.difficulty - total);
      updates.pvCurrent = Math.max(0, player.pvCurrent - damage);
    }
    await updatePlayer(updates);

    setTimeout(() => setAttemptResult(null), 3000);
  };

  const completeExchangeQuest = async (questId, questText) => {
    if (!isMyTurn) return;
    const questInfo = parseQuest(questText);
    if (!questInfo.isExchange) return;
    if (player[questInfo.resourceKey] < questInfo.resourceAmount) {
      alert(`Ressources insuffisantes ! (${player[questInfo.resourceKey]}/${questInfo.resourceAmount})`);
      return;
    }
    const pdvBonus = rulesEngine.getQuestPdvBonus(player);
    await updatePlayer({
      quests: (player.quests || []).filter(q => q.id !== questId),
      [questInfo.resourceKey]: player[questInfo.resourceKey] - questInfo.resourceAmount,
      pdv: player.pdv + questInfo.pdv + pdvBonus,
      pdvHistory: [...(player.pdvHistory || []), { id: `pdv_${Date.now()}`, amount: questInfo.pdv + pdvBonus, source: 'QUEST' }]
    });
  };

  const resetDeck = async () => {
    if (confirm("RÃ©initialiser le deck de quÃªtes ?")) {
      await updateGame({ drawnQuetes: [] });
      setCurrentCard(null);
    }
  };

  const remaining = QUETES.length - (gameState.drawnQuetes || []).length;

  return React.createElement("div", { className: "space-y-6" },
    React.createElement("div", { className: "text-center" },
      React.createElement("h3", { className: "text-2xl font-bold text-gray-800 mb-2" }, "ðŸ“œ QuÃªtes"),
      React.createElement("p", { className: "text-gray-600" }, `Cartes restantes: ${remaining} / ${QUETES.length}`)
    ),
    React.createElement("div", { className: `min-h-[180px] bg-gradient-to-r from-green-600 to-green-800 rounded-xl p-6 flex items-center justify-center transition-all ${isAnimating ? 'scale-95 opacity-50' : ''}` },
      currentCard ? React.createElement("p", { className: "text-sm text-center text-white font-medium" }, currentCard) : React.createElement("p", { className: "text-gray-300 text-center italic" }, 'Cliquez sur "Tirer une quÃªte"')
    ),

    attemptResult && React.createElement("div", { className: `bg-gradient-to-r ${attemptResult.success ? 'from-green-600 to-green-800' : 'from-red-600 to-red-800'} rounded-xl p-6 text-white` },
      React.createElement("div", { className: "text-center mb-4" },
        React.createElement("div", { className: "text-2xl font-bold" }, attemptResult.success ? "âœ… SUCCÃˆS" : "âŒ Ã‰CHEC"),
        React.createElement("div", { className: "text-4xl font-bold mt-2" }, `${attemptResult.total} vs ${attemptResult.difficulty}`)
      ),
      React.createElement("div", { className: "bg-white bg-opacity-20 rounded-lg p-3 text-sm" },
        React.createElement("p", null, `DÃ©: ${attemptResult.diceRoll}`),
        React.createElement("p", null, `Base: ${attemptResult.baseStat >= 0 ? '+' : ''}${attemptResult.baseStat}`),
        React.createElement("p", null, `Ã‰tats: ${attemptResult.effectsBonus >= 0 ? '+' : ''}${attemptResult.effectsBonus}`),
        attemptResult.questBonus > 0 && React.createElement("p", null, `Bonus quÃªte: +${attemptResult.questBonus}`)
      )
    ),

    pendingQuest && React.createElement("div", { className: "bg-yellow-50 border-2 border-yellow-400 rounded-xl p-4" },
      React.createElement("h4", { className: "font-bold text-gray-800 mb-3" }, "âš ï¸ Limite de quÃªtes (2 max)"),
      React.createElement("p", { className: "text-sm text-gray-700 mb-3" }, pendingQuest.text),
      React.createElement("div", { className: "space-y-2 mb-3" },
        (player.quests || []).map(q => React.createElement("button", {
          key: q.id, onClick: () => handleQuestChoice('replace', q.id),
          className: "w-full text-left p-2 bg-white border rounded-lg hover:border-red-500 text-xs"
        }, `Remplacer: ${q.text}`))
      ),
      React.createElement("button", { onClick: () => handleQuestChoice('refuse'), className: "w-full py-2 bg-gray-600 text-white rounded-lg font-semibold" }, "Refuser")
    ),

    React.createElement("div", { className: "grid grid-cols-2 gap-4" },
      React.createElement("button", { onClick: drawCard, disabled: !isMyTurn || isAnimating || pendingQuest, className: `py-4 rounded-xl font-semibold ${isMyTurn && !pendingQuest ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-gray-300 text-gray-500'}` }, "Tirer une quÃªte"),
      React.createElement("button", { onClick: resetDeck, className: "py-4 bg-gray-600 text-white rounded-xl font-semibold hover:bg-gray-700" }, "RÃ©initialiser")
    ),

    React.createElement("div", null,
      React.createElement("h4", { className: "text-lg font-bold text-gray-800 mb-3" }, `Mes quÃªtes (${(player.quests || []).length}/2)`),
      (player.quests || []).length === 0 ? React.createElement("p", { className: "text-gray-500 text-center py-4" }, "Aucune quÃªte") :
      React.createElement("div", { className: "space-y-2" },
        (player.quests || []).map(quest => {
          const info = parseQuest(quest.text);
          const hasRes = info.isExchange ? player[info.resourceKey] >= info.resourceAmount : true;
          return React.createElement("div", { key: quest.id, className: `rounded-lg p-3 border-2 ${info.isExchange && !hasRes ? 'bg-red-50 border-red-300' : 'bg-gray-50 border-gray-300'}` },
            React.createElement("p", { className: "text-sm text-gray-700 mb-2" }, quest.text),
            info.isCombat && React.createElement("div", { className: "flex items-center justify-between" },
              React.createElement("span", { className: "text-xs text-blue-600" }, `DifficultÃ© ${info.difficulty} en ${info.statName}`),
              React.createElement("button", { onClick: () => attemptQuest(quest.id, quest.text), disabled: !isMyTurn || player.usedAttackDice, className: `px-4 py-2 rounded-lg font-semibold text-sm ${isMyTurn && !player.usedAttackDice ? 'bg-orange-600 text-white' : 'bg-gray-300 text-gray-500'}` }, "âš”ï¸ Tenter")
            ),
            info.isExchange && React.createElement("div", { className: "flex items-center justify-between" },
              React.createElement("span", { className: `text-xs ${hasRes ? 'text-green-600' : 'text-red-600'}` }, `${player[info.resourceKey]}/${info.resourceAmount} ${info.resourceDisplayName}`),
              React.createElement("button", { onClick: () => completeExchangeQuest(quest.id, quest.text), disabled: !isMyTurn || !hasRes, className: `px-4 py-2 rounded-lg font-semibold text-sm ${isMyTurn && hasRes ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-500'}` }, "âœ“ Valider")
            )
          );
        })
      )
    )
  );
}

// ============= STATISTIQUE TAB =============
function StatistiqueTab() {
  const [currentStat, setCurrentStat] = useState(null);
  const [isAnimating, setIsAnimating] = useState(false);

  const drawStat = () => {
    setIsAnimating(true);
    setTimeout(() => {
      setCurrentStat(STATISTIQUES[Math.floor(Math.random() * STATISTIQUES.length)]);
      setIsAnimating(false);
    }, 300);
  };

  return React.createElement("div", { className: "space-y-6" },
    React.createElement("h3", { className: "text-2xl font-bold text-center text-gray-800" }, "ðŸ“Š Statistique alÃ©atoire"),
    React.createElement("div", { className: `min-h-[180px] bg-gradient-to-r from-blue-600 to-blue-800 rounded-xl p-6 flex items-center justify-center transition-all ${isAnimating ? 'scale-95 opacity-50' : ''}` },
      currentStat ? React.createElement("p", { className: "text-4xl text-center text-white font-bold" }, currentStat) : React.createElement("p", { className: "text-gray-300 text-center italic" }, 'Cliquez pour tirer')
    ),
    React.createElement("button", { onClick: drawStat, disabled: isAnimating, className: "w-full py-4 bg-blue-600 text-white rounded-xl font-semibold hover:bg-blue-700" }, "Tirer une statistique")
  );
}

// ============= DE TAB =============
function DeTab({ player, gameState, players, updatePlayer, playerIndex, isMyTurn }) {
  const [moveResult, setMoveResult] = useState(null);
  const [attackResult, setAttackResult] = useState(null);
  const [combatMode, setCombatMode] = useState(null);
  const [selectedOpponent, setSelectedOpponent] = useState(null);
  const [combatResult, setCombatResult] = useState(null);
  const [isAnimating, setIsAnimating] = useState(false);

  // Use players prop or fallback
  const allPlayers = players || (Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null));

  const rollMove = () => {
    setIsAnimating(true);
    setTimeout(() => {
      setMoveResult(Math.floor(Math.random() * 10));
      setIsAnimating(false);
    }, 800);
  };

  const rollAttack = async () => {
    if (!isMyTurn || player.usedAttackDice) { alert("Jet d'attaque dÃ©jÃ  utilisÃ© !"); return; }
    setIsAnimating(true);

    setTimeout(async () => {
      const statIdx = Math.floor(Math.random() * STATISTIQUES.length);
      const stat = STATISTIQUES[statIdx];
      const statKey = STAT_MAPPING[stat];
      const diceRoll = Math.floor(Math.random() * 10);
      const baseStat = (player.baseStats && player.baseStats[statKey]) || 0;
      const effectsBonus = (player.effects || []).filter(e => e.stat === statKey).reduce((s, e) => s + e.delta, 0);
      const total = diceRoll + baseStat + effectsBonus;

      setAttackResult({ stat, statKey, diceRoll, baseStat, effectsBonus, total });
      await updatePlayer(playerIndex, { usedAttackDice: true });
      setIsAnimating(false);
    }, 800);
  };

  const startCombat = () => {
    if (!isMyTurn || player.usedAttackDice) { alert("Jet d'attaque dÃ©jÃ  utilisÃ© !"); return; }
    setCombatMode('select');
  };

  const executeCombat = async (oppIdx, statKey, statName) => {
    setIsAnimating(true);
    const opponent = allPlayers[oppIdx];
    if (!opponent) { setIsAnimating(false); return; }

    setTimeout(async () => {
      const atkDice = Math.floor(Math.random() * 10);
      const defDice = Math.floor(Math.random() * 10);
      const atkBase = (player.baseStats && player.baseStats[statKey]) || 0;
      const atkEff = (player.effects || []).filter(e => e.stat === statKey).reduce((s, e) => s + e.delta, 0);
      const defBase = (opponent.baseStats && opponent.baseStats[statKey]) || 0;
      const defEff = (opponent.effects || []).filter(e => e.stat === statKey).reduce((s, e) => s + e.delta, 0);
      const atkTotal = atkDice + atkBase + atkEff;
      const defTotal = defDice + defBase + defEff;
      const diff = atkTotal - defTotal;

      const result = { stat: statName, atkDice, defDice, atkBase, atkEff, defBase, defEff, atkTotal, defTotal, diff, opponentName: opponent.playerName };

      const updates = { usedAttackDice: true };
      const oppUpdates = {};

      if (diff > 0) {
        result.winner = 'attacker';
        oppUpdates.pvCurrent = Math.max(0, opponent.pvCurrent - diff);
        const heal = rulesEngine.getHealOnWin(player);
        if (heal > 0) updates.pvCurrent = Math.min(player.character.pvMax, player.pvCurrent + heal);
        if (opponent.pvCurrent - diff <= 0) {
          result.killed = true;
          const pdvGain = 1 + rulesEngine.getCursedKillBonus(player, opponent);
          updates.pdv = player.pdv + pdvGain;
          updates.pdvHistory = [...(player.pdvHistory || []), { id: `pdv_${Date.now()}`, amount: pdvGain, source: 'COMBAT' }];
        }
      } else if (diff < 0) {
        result.winner = 'defender';
        const counter = rulesEngine.getCounterDamage(opponent);
        if (counter > 0) updates.pvCurrent = Math.max(0, player.pvCurrent - counter);
      } else {
        result.winner = 'draw';
      }

      setCombatResult(result);
      await updatePlayer(playerIndex, updates);
      if (Object.keys(oppUpdates).length > 0) await updatePlayer(oppIdx, oppUpdates);
      setIsAnimating(false);
      setCombatMode(null);
      setSelectedOpponent(null);
    }, 1000);
  };

  const opponents = allPlayers.filter((p, i) => p && i !== playerIndex);

  return React.createElement("div", { className: "space-y-6" },
    React.createElement("h3", { className: "text-2xl font-bold text-center text-gray-800" }, "ðŸŽ² Lancers de dÃ©s"),

    React.createElement("div", { className: "grid grid-cols-2 gap-4" },
      React.createElement("div", { className: "bg-blue-50 rounded-xl p-4" },
        React.createElement("h4", { className: "font-bold text-blue-800 mb-3 text-center" }, "DÃ©placement"),
        React.createElement("div", { className: `h-24 bg-gradient-to-r from-blue-600 to-blue-800 rounded-xl flex items-center justify-center mb-3 ${isAnimating ? 'animate-pulse' : ''}` },
          moveResult !== null ? React.createElement("span", { className: "text-5xl font-bold text-white" }, moveResult) : React.createElement("span", { className: "text-gray-300" }, "â€”")
        ),
        React.createElement("button", { onClick: rollMove, disabled: isAnimating, className: "w-full py-3 bg-blue-600 text-white rounded-lg font-semibold" }, "Lancer")
      ),

      React.createElement("div", { className: "bg-red-50 rounded-xl p-4" },
        React.createElement("h4", { className: "font-bold text-red-800 mb-3 text-center" }, "Attaque"),
        React.createElement("div", { className: `h-24 bg-gradient-to-r from-red-600 to-red-800 rounded-xl flex items-center justify-center mb-3 ${isAnimating ? 'animate-pulse' : ''}` },
          attackResult ? React.createElement("div", { className: "text-center text-white" },
            React.createElement("div", { className: "text-4xl font-bold" }, attackResult.total),
            React.createElement("div", { className: "text-xs" }, attackResult.stat)
          ) : React.createElement("span", { className: "text-gray-300" }, "â€”")
        ),
        React.createElement("button", { onClick: rollAttack, disabled: !isMyTurn || player.usedAttackDice || isAnimating, className: `w-full py-3 rounded-lg font-semibold ${isMyTurn && !player.usedAttackDice ? 'bg-red-600 text-white' : 'bg-gray-300 text-gray-500'}` }, player.usedAttackDice ? "UtilisÃ©" : "Lancer")
      )
    ),

    attackResult && React.createElement("div", { className: "bg-gray-50 rounded-xl p-4" },
      React.createElement("h4", { className: "font-bold text-gray-800 mb-2" }, "DÃ©tails du jet d'attaque"),
      React.createElement("div", { className: "grid grid-cols-3 gap-2 text-center text-sm" },
        React.createElement("div", null, React.createElement("p", { className: "text-gray-500" }, "DÃ©"), React.createElement("p", { className: "font-bold" }, attackResult.diceRoll)),
        React.createElement("div", null, React.createElement("p", { className: "text-gray-500" }, "Base"), React.createElement("p", { className: "font-bold" }, attackResult.baseStat >= 0 ? `+${attackResult.baseStat}` : attackResult.baseStat)),
        React.createElement("div", null, React.createElement("p", { className: "text-gray-500" }, "Ã‰tats"), React.createElement("p", { className: "font-bold" }, attackResult.effectsBonus >= 0 ? `+${attackResult.effectsBonus}` : attackResult.effectsBonus))
      )
    ),

    React.createElement("div", { className: "bg-orange-50 rounded-xl p-4" },
      React.createElement("h4", { className: "font-bold text-orange-800 mb-3" }, "âš”ï¸ Combat joueur"),
      combatMode === 'select' ? React.createElement("div", { className: "space-y-2" },
        React.createElement("p", { className: "text-sm text-gray-600 mb-2" }, "Choisissez un adversaire :"),
        opponents.map((opp, i) => React.createElement("button", {
          key: opp.id, onClick: () => { setSelectedOpponent(allPlayers.indexOf(opp)); setCombatMode('stat'); },
          className: "w-full p-3 bg-white border-2 border-orange-300 rounded-lg text-left hover:border-orange-500"
        },
          React.createElement("span", { className: "font-bold" }, opp.playerName),
          React.createElement("span", { className: "text-sm text-gray-500 ml-2" }, `(${opp.character.name} - ${opp.pvCurrent} PV)`)
        )),
        React.createElement("button", { onClick: () => setCombatMode(null), className: "w-full py-2 bg-gray-200 rounded-lg mt-2" }, "Annuler")
      ) : combatMode === 'stat' && rulesEngine.canChooseStat(player) ? React.createElement("div", { className: "space-y-2" },
        React.createElement("p", { className: "text-sm text-gray-600 mb-2" }, "Choisissez la statistique (HÃ©rÃ©tique) :"),
        Object.entries(STAT_NAMES).map(([key, name]) => React.createElement("button", {
          key, onClick: () => executeCombat(selectedOpponent, key, name),
          className: "w-full p-2 bg-white border rounded-lg hover:bg-purple-50"
        }, name)),
        React.createElement("button", { onClick: () => setCombatMode('select'), className: "w-full py-2 bg-gray-200 rounded-lg mt-2" }, "Retour")
      ) : combatMode === 'stat' ? (() => {
        const stat = STATISTIQUES[Math.floor(Math.random() * STATISTIQUES.length)];
        const statKey = STAT_MAPPING[stat];
        setTimeout(() => executeCombat(selectedOpponent, statKey, stat), 100);
        return React.createElement("p", { className: "text-center text-gray-600" }, "Tirage de la stat...");
      })() : React.createElement("button", { onClick: startCombat, disabled: !isMyTurn || player.usedAttackDice, className: `w-full py-3 rounded-lg font-semibold ${isMyTurn && !player.usedAttackDice ? 'bg-orange-600 text-white' : 'bg-gray-300 text-gray-500'}` }, "Lancer un combat")
    ),

    combatResult && React.createElement("div", { className: `rounded-xl p-4 ${combatResult.winner === 'attacker' ? 'bg-green-100' : combatResult.winner === 'defender' ? 'bg-red-100' : 'bg-yellow-100'}` },
      React.createElement("h4", { className: "font-bold text-gray-800 mb-2" }, `Combat vs ${combatResult.opponentName}`),
      React.createElement("div", { className: "grid grid-cols-2 gap-4 text-center" },
        React.createElement("div", null, React.createElement("p", { className: "text-sm text-gray-500" }, "Vous"), React.createElement("p", { className: "text-3xl font-bold" }, combatResult.atkTotal)),
        React.createElement("div", null, React.createElement("p", { className: "text-sm text-gray-500" }, "Adversaire"), React.createElement("p", { className: "text-3xl font-bold" }, combatResult.defTotal))
      ),
      React.createElement("p", { className: `text-center font-bold mt-3 ${combatResult.winner === 'attacker' ? 'text-green-600' : combatResult.winner === 'defender' ? 'text-red-600' : 'text-yellow-600'}` },
        combatResult.winner === 'attacker' ? `âœ… Victoire ! ${Math.abs(combatResult.diff)} dÃ©gÃ¢ts infligÃ©s${combatResult.killed ? ' - KILL !' : ''}` : combatResult.winner === 'defender' ? 'âŒ DÃ©faite !' : 'ðŸ¤ Ã‰galitÃ© !'
      )
    )
  );
}

// ============= PERSONNAGE TAB =============
function PersonnageTab({ player, updatePlayer, gameState, players, updateGame, playerIndex, onPassStart, isMyTurn }) {
  const [subTab, setSubTab] = useState('global');
  const [newEffect, setNewEffect] = useState({ type: 'BLESS', stat: 'endurance' });
  const [showTargetSelect, setShowTargetSelect] = useState(null);
  const [selectedStat, setSelectedStat] = useState('endurance');

  // Use players prop or fallback
  const allPlayers = players || (Array.isArray(gameState.players) ? gameState.players : Array(gameState.playerCount).fill(null).map((_, i) => gameState.players?.[i] || null));

  const adjustPv = (d) => isMyTurn && updatePlayer({ pvCurrent: Math.max(0, Math.min(player.character.pvMax, player.pvCurrent + d)) });
  const adjustResource = (key, d) => isMyTurn && updatePlayer({ [key]: Math.max(0, player[key] + d) });

  const addEffect = async () => {
    if (!isMyTurn) return;
    const effect = { id: `eff_${Date.now()}`, type: newEffect.type, stat: newEffect.stat, name: newEffect.type === 'BLESS' ? 'BÃ©nÃ©diction' : 'MalÃ©diction', delta: newEffect.type === 'BLESS' ? 2 : -2 };
    await updatePlayer({ effects: [...(player.effects || []), effect] });
  };

  const removeEffect = async (id) => isMyTurn && updatePlayer({ effects: (player.effects || []).filter(e => e.id !== id) });

  const applyEffectToTarget = async (targetIdx, effectType) => {
    const target = allPlayers[targetIdx];
    if (!target) return;
    const effect = { id: `eff_${Date.now()}`, type: effectType === 'bless' ? 'BLESS' : 'CURSE', stat: selectedStat, name: effectType === 'bless' ? `BÃ©nÃ©diction (${player.character.name})` : `MalÃ©diction (${player.character.name})`, delta: effectType === 'bless' ? 2 : -2 };
    
    const targetUpdates = { effects: [...(target.effects || []), effect] };
    const myUpdates = effectType === 'bless' ? { blessAvailable: false } : { curseAvailable: false };
    
    await updateGame({ [`players/${targetIdx}/effects`]: targetUpdates.effects });
    await updatePlayer(myUpdates);
    setShowTargetSelect(null);
  };

  const effectiveStats = rulesEngine.computeEffectiveStats(player);
  const territories = countTerritoriesByBiome(player.territories);

  if (showTargetSelect) {
    const isBless = showTargetSelect === 'bless';
    return React.createElement("div", { className: "space-y-4" },
      React.createElement("h3", { className: `text-xl font-bold text-center ${isBless ? 'text-green-700' : 'text-red-700'}` }, isBless ? "âœ¨ BÃ©nÃ©diction" : "ðŸ’€ MalÃ©diction"),
      React.createElement("select", { value: selectedStat, onChange: e => setSelectedStat(e.target.value), className: "w-full p-3 border-2 rounded-lg" },
        Object.entries(STAT_NAMES).map(([k, n]) => React.createElement("option", { key: k, value: k }, n))
      ),
      React.createElement("div", { className: "space-y-2" },
        allPlayers.map((p, idx) => p && React.createElement("button", {
          key: p.id || idx, onClick: () => applyEffectToTarget(idx, showTargetSelect),
          className: `w-full p-4 rounded-xl border-2 text-left ${isBless ? 'border-green-400 bg-green-50' : 'border-red-400 bg-red-50'}`
        }, React.createElement("span", { className: "font-bold" }, `${p.playerName} - ${p.character?.name || 'Personnage'}`)))
      ),
      React.createElement("button", { onClick: () => setShowTargetSelect(null), className: "w-full py-3 bg-gray-600 text-white rounded-xl font-semibold" }, "Annuler")
    );
  }

  const ResBox = ({ icon, label, val, k }) => React.createElement("div", { className: "bg-white bg-opacity-20 rounded-lg p-3" },
    React.createElement("div", { className: "text-sm font-semibold mb-2 text-center" }, `${icon} ${label}`),
    React.createElement("div", { className: "text-3xl font-bold text-center mb-2" }, val),
    React.createElement("div", { className: "flex gap-2" },
      React.createElement("button", { onClick: () => adjustResource(k, -1), className: "flex-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded py-2 font-semibold" }, "-1"),
      React.createElement("button", { onClick: () => adjustResource(k, 1), className: "flex-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded py-2 font-semibold" }, "+1")
    )
  );

  return React.createElement("div", { className: "space-y-4" },
    React.createElement("div", { className: "text-center" },
      React.createElement("h2", { className: "text-3xl font-bold text-gray-800" }, player.character.name),
      React.createElement("p", { className: "text-gray-600" }, player.playerName)
    ),

    React.createElement("div", { className: "flex gap-1" },
      ['global', 'stats', 'effets', 'skills'].map(tab => React.createElement("button", {
        key: tab, onClick: () => setSubTab(tab),
        className: `flex-1 py-2 rounded-lg font-semibold text-sm ${subTab === tab ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-600'}`
      }, tab === 'global' ? 'ðŸŽ¯ Global' : tab === 'stats' ? 'ðŸ“Š Stats' : tab === 'effets' ? 'ðŸ’« Ã‰tats' : 'âš”ï¸ Skills'))
    ),

    subTab === 'global' && React.createElement("div", { className: "space-y-4" },
      React.createElement("div", { className: "bg-gradient-to-r from-red-500 to-pink-500 rounded-2xl p-6 text-white" },
        React.createElement("div", { className: "text-center mb-4" },
          React.createElement("div", { className: "text-sm font-semibold mb-2" }, "Points de Vie"),
          React.createElement("div", { className: "text-5xl font-bold" }, `${player.pvCurrent} / ${player.character.pvMax}`)
        ),
        React.createElement("div", { className: "flex gap-2" },
          [-5, -1].map(d => React.createElement("button", { key: d, onClick: () => adjustPv(d), className: "flex-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg py-2 font-semibold" }, d)),
          React.createElement("button", { onClick: () => isMyTurn && updatePlayer({ pvCurrent: player.character.pvMax }), className: "flex-1 bg-white text-red-600 rounded-lg py-2 font-semibold text-sm" }, "Max"),
          [1, 5].map(d => React.createElement("button", { key: d, onClick: () => adjustPv(d), className: "flex-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg py-2 font-semibold" }, `+${d}`))
        )
      ),

      React.createElement("button", { onClick: onPassStart, disabled: !isMyTurn, className: `w-full py-4 rounded-xl font-bold text-lg ${isMyTurn ? 'bg-gradient-to-r from-amber-500 to-yellow-500 text-white' : 'bg-gray-300 text-gray-500'}` }, "ðŸ Passage par le DÃ©part"),

      React.createElement("div", { className: "bg-gradient-to-r from-amber-500 to-yellow-500 rounded-2xl p-6 text-white" },
        React.createElement("h3", { className: "text-xl font-bold mb-4 text-center" }, "Ressources"),
        React.createElement("div", { className: "grid grid-cols-2 gap-3" },
          React.createElement(ResBox, { icon: "ðŸª™", label: "Or", val: player.or, k: "or" }),
          React.createElement(ResBox, { icon: "ðŸŒ³", label: "Cuivre", val: player.cuivre, k: "cuivre" }),
          React.createElement(ResBox, { icon: "ðŸœï¸", label: "Argent", val: player.argent, k: "argent" }),
          React.createElement(ResBox, { icon: "â›°ï¸", label: "Obsidienne", val: player.obsidienne, k: "obsidienne" }),
          React.createElement(ResBox, { icon: "ðŸ†", label: "PDV", val: player.pdv, k: "pdv" }),
          React.createElement(ResBox, { icon: "ðŸŽ²", label: "Tour", val: player.tourPlateau, k: "tourPlateau" })
        )
      ),

      (player.territories || []).length > 0 && React.createElement("div", null,
        React.createElement("h3", { className: "text-xl font-bold text-gray-800 mb-3" }, `ðŸ° Territoires (${player.territories.length})`),
        React.createElement("div", { className: "flex gap-2 flex-wrap" },
          (player.territories || []).map(t => React.createElement("div", { key: t.id, className: `px-4 py-2 rounded-lg bg-gradient-to-br ${BIOMES[t.biome].color} text-white font-bold` },
            `${BIOMES[t.biome].emoji} ${BIOMES[t.biome].name.split(' ')[0]}`
          ))
        )
      )
    ),

    subTab === 'stats' && React.createElement("div", { className: "space-y-3" },
      Object.entries(STAT_NAMES).map(([key, name]) => {
        const base = (player.baseStats && player.baseStats[key]) || 0;
        const bonus = (player.effects || []).filter(e => e.stat === key).reduce((s, e) => s + e.delta, 0);
        const total = base + bonus;
        return React.createElement("div", { key, className: "bg-gray-50 rounded-lg p-3 flex items-center justify-between" },
          React.createElement("span", { className: "font-semibold text-gray-700" }, name),
          React.createElement("div", { className: "flex items-center gap-3" },
            React.createElement("span", { className: "text-sm text-gray-500" }, `Base: ${base >= 0 ? '+' : ''}${base}`),
            bonus !== 0 && React.createElement("span", { className: `text-sm ${bonus > 0 ? 'text-green-600' : 'text-red-600'}` }, `Ã‰tats: ${bonus > 0 ? '+' : ''}${bonus}`),
            React.createElement("span", { className: `font-bold text-lg ${total >= 0 ? 'text-green-600' : 'text-red-600'}` }, `= ${total > 0 ? '+' : ''}${total}`)
          )
        );
      })
    ),

    subTab === 'effets' && React.createElement("div", { className: "space-y-4" },
      rulesEngine.canBless(player) && React.createElement("div", { className: `p-4 rounded-xl border-2 ${player.blessAvailable ? 'bg-green-50 border-green-400' : 'bg-gray-100 border-gray-300 opacity-60'}` },
        React.createElement("div", { className: "flex justify-between items-center" },
          React.createElement("div", null,
            React.createElement("div", { className: "font-bold text-green-700" }, "âœ¨ BÃ©nÃ©diction (Vicaire)"),
            React.createElement("p", { className: "text-sm text-gray-600" }, "+2 Ã  une stat d'un joueur")
          ),
          React.createElement("button", { onClick: () => player.blessAvailable && isMyTurn && setShowTargetSelect('bless'), disabled: !player.blessAvailable || !isMyTurn, className: `px-4 py-2 rounded-lg font-semibold ${player.blessAvailable && isMyTurn ? 'bg-green-600 text-white' : 'bg-gray-400 text-white'}` }, player.blessAvailable ? 'Utiliser' : 'UtilisÃ©')
        )
      ),

      rulesEngine.canCurse(player) && React.createElement("div", { className: `p-4 rounded-xl border-2 ${player.curseAvailable ? 'bg-red-50 border-red-400' : 'bg-gray-100 border-gray-300 opacity-60'}` },
        React.createElement("div", { className: "flex justify-between items-center" },
          React.createElement("div", null,
            React.createElement("div", { className: "font-bold text-red-700" }, "ðŸ’€ MalÃ©diction (HÃ©rÃ©tique)"),
            React.createElement("p", { className: "text-sm text-gray-600" }, "-2 Ã  une stat d'un joueur")
          ),
          React.createElement("button", { onClick: () => player.curseAvailable && isMyTurn && setShowTargetSelect('curse'), disabled: !player.curseAvailable || !isMyTurn, className: `px-4 py-2 rounded-lg font-semibold ${player.curseAvailable && isMyTurn ? 'bg-red-600 text-white' : 'bg-gray-400 text-white'}` }, player.curseAvailable ? 'Utiliser' : 'UtilisÃ©')
        )
      ),

      React.createElement("div", { className: "bg-purple-50 rounded-xl p-4" },
        React.createElement("h4", { className: "font-bold text-gray-800 mb-3" }, `Ã‰tats actifs (${(player.effects || []).length})`),
        (player.effects || []).length === 0 ? React.createElement("p", { className: "text-gray-500 text-center py-2" }, "Aucun Ã©tat") :
        React.createElement("div", { className: "space-y-2 mb-4" },
          (player.effects || []).map(e => React.createElement("div", { key: e.id, className: `flex justify-between items-center p-3 rounded-lg ${e.type === 'BLESS' ? 'bg-green-100 border border-green-400' : 'bg-red-100 border border-red-400'}` },
            React.createElement("div", null,
              React.createElement("span", { className: e.type === 'BLESS' ? 'text-green-700 font-bold' : 'text-red-700 font-bold' }, `${e.type === 'BLESS' ? 'âœ¨' : 'ðŸ’€'} ${e.name}`),
              React.createElement("span", { className: "text-gray-600 ml-2 text-sm" }, `(${STAT_NAMES[e.stat]}: ${e.delta >= 0 ? '+' : ''}${e.delta})`)
            ),
            React.createElement("button", { onClick: () => removeEffect(e.id), className: "px-3 py-1 bg-red-500 text-white rounded text-sm" }, "âœ•")
          ))
        ),

        React.createElement("div", { className: "border-t border-purple-200 pt-4" },
          React.createElement("h5", { className: "font-semibold text-gray-700 mb-2" }, "Ajouter un Ã©tat"),
          React.createElement("div", { className: "grid grid-cols-2 gap-2 mb-2" },
            React.createElement("button", { onClick: () => setNewEffect({ ...newEffect, type: 'BLESS' }), className: `py-2 rounded-lg font-semibold ${newEffect.type === 'BLESS' ? 'bg-green-600 text-white' : 'bg-gray-200'}` }, "âœ¨ BÃ©nÃ©diction"),
            React.createElement("button", { onClick: () => setNewEffect({ ...newEffect, type: 'CURSE' }), className: `py-2 rounded-lg font-semibold ${newEffect.type === 'CURSE' ? 'bg-red-600 text-white' : 'bg-gray-200'}` }, "ðŸ’€ MalÃ©diction")
          ),
          React.createElement("select", { value: newEffect.stat, onChange: e => setNewEffect({ ...newEffect, stat: e.target.value }), className: "w-full p-2 border rounded-lg mb-2" },
            Object.entries(STAT_NAMES).map(([k, n]) => React.createElement("option", { key: k, value: k }, n))
          ),
          React.createElement("button", { onClick: addEffect, disabled: !isMyTurn, className: `w-full py-2 rounded-lg font-semibold ${isMyTurn ? 'bg-purple-600 text-white' : 'bg-gray-300 text-gray-500'}` }, "Ajouter")
        )
      )
    ),

    subTab === 'skills' && React.createElement("div", { className: "space-y-4" },
      React.createElement("div", { className: "bg-blue-50 rounded-xl p-4" },
        React.createElement("p", { className: "text-sm text-gray-600 mb-2" }, React.createElement("strong", null, "RÃ´le: "), player.character.role),
        React.createElement("p", { className: "text-sm text-gray-700 italic mb-4" }, player.character.concept),
        React.createElement("div", { className: "space-y-2" },
          (player.skills || []).map((skill, idx) => React.createElement("div", { key: skill.id, className: "bg-white rounded-lg p-3" },
            React.createElement("p", { className: "text-sm text-gray-700" }, `${idx + 1}. ${skill.description}`)
          ))
        ),
        React.createElement("p", { className: "text-xs text-gray-600 mt-4 italic" }, React.createElement("strong", null, "Style: "), player.character.style)
      )
    )
  );
}

// ============= RENDER =============
createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>
</body>
</html>
